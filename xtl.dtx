% \iffalse
%% File: xtl.dtx Copyright (C) 2013 Bruno Le Floch
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% -----------------------------------------------------------------------
%
%<*driver>
%\fi
%\iffalse
\documentclass[full]{l3doc}
\usepackage{xtl}
\begin{document}
  \DocInput{xtl.dtx}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{xtl} package: \\
%   manipulate unbalanced lists of tokens\thanks{This
%     file has version number 0.0a, last revised 2013/07/14.}}
% \author{Bruno Le Floch}
% \date{2013/07/14}
%
% \maketitle
% \tableofcontents
%
% \begin{documentation}
%
% \section{\pkg{xtl} documentation}
%
% The \texttt{expl3} programming language provides various tools to
% manipulate lists of tokens (package \pkg{l3tl}).  However, those token
% lists must have balanced braces, or more precisely balanced
% begin-group and end-group characters.  The \pkg{xtl} package
% manipulates instead lists of tokens which may be unbalanced, with more
% begin-group or more end-group characters.
%
% \subsection{Creating and initialising extended token lists}
%
% \begin{function}{\xtl_new:N}
%   \begin{syntax}
%     \cs{xtl_new:N} \meta{xtl~var}
%   \end{syntax}
%   Creates a new \meta{xtl~var} or raises an error if the name is
%   already taken.  The declaration is global.  The \meta{xtl~var} will
%   initially be empty.
% \end{function}
%
% \begin{function}{\xtl_const:Nn, \xtl_const:Nx}
%   \begin{syntax}
%     \cs{xtl_const:Nn} \meta{xtl~var} \Arg{token list}
%   \end{syntax}
%   Creates a new constant \meta{xtl~var} or raises an error if the name
%   is already taken.  The value of the \meta{xtl~var} will be set
%   globally to the balanced \meta{token list}.
% \end{function}
%
% \begin{function}{\xtl_clear:N, \xtl_gclear:N}
%   \begin{syntax}
%     \cs{xtl_clear:N} \meta{xtl~var}
%   \end{syntax}
%   Empties the \meta{xtl~var}, locally or globally.
% \end{function}
%
% \begin{function}{\xtl_clear_new:N, \xtl_gclear_new:N}
%   \begin{syntax}
%     \cs{xtl_clear_new:N} \meta{xtl~var}
%   \end{syntax}
%   Ensures that the \meta{xtl~var} exists globally by applying
%   \cs{xtl_new:N} if necessary, then applies \cs{xtl_(g)clear:N} to
%   leave the \meta{xtl~var} empty.
% \end{function}
%
% \begin{function}{\xtl_set_eq:NN, \xtl_gset_eq:NN}
%   \begin{syntax}
%     \cs{xtl_set_eq:NN} \meta{xtl~var_1} \meta{xtl~var_2}
%   \end{syntax}
%   Sets the content of \meta{xtl~var_1} equal to that of
%   \meta{xtl~var_2}.
% \end{function}
%
% \begin{function}{\xtl_concat:NNN, \xtl_gconcat:NNN}
%   \begin{syntax}
%     \cs{xtl_concat:NNN} \meta{xtl~var_1} \meta{xtl~var_2} \meta{xtl~var_3}
%   \end{syntax}
%   Concatenates the content of \meta{xtl~var_2} and \meta{xtl~var_3}
%   together and saves the result in \meta{xtl~var_1}. The
%   \meta{xtl~var_2} will be placed at the left side of the new extended
%   token list.
% \end{function}
%
% \begin{function}[EXP, pTF]{\xtl_if_exist:N}
%   \begin{syntax}
%     \cs{xtl_if_exist_p:N} \meta{xtl~var}
%     \cs{xtl_if_exist:NTF} \meta{xtl~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the \meta{xtl~var} is currently defined.  This does
%   not check that the \meta{xtl~var} really is an extended token list
%   variable.
% \end{function}
%
% \subsection{Adding data to token list variables}
%
% \begin{function}{\xtl_set:Nn, \xtl_set:Nx, \xtl_gset:Nn, \xtl_gset:Nx}
%   \begin{syntax}
%     \cs{xtl_set:Nn} \meta{xtl~var} \Arg{token list}
%   \end{syntax}
%   Sets \meta{xtl~var} to contain the balanced \meta{token list},
%   removing any previous content from the variable.
% \end{function}
%
% \begin{function}{\xtl_put_left:Nn, \xtl_gput_left:Nn}
%   \begin{syntax}
%     \cs{xtl_put_left:Nn} \meta{xtl~var} \Arg{token list}
%   \end{syntax}
%   Appends the balanced \meta{token list} to the left side of the
%   current content of \meta{xtl~var}.
% \end{function}
%
% \begin{function}{\xtl_put_right:Nn, \xtl_gput_right:Nn}
%   \begin{syntax}
%     \cs{xtl_put_right:Nn} \meta{xtl~var} \Arg{token list}
%   \end{syntax}
%   Appends the balanced \meta{token list} to the right side of the
%   current content of \meta{xtl~var}.
% \end{function}
%
% \section{Extended token list conditionals}
%
% \begin{function}[EXP, pTF]{\xtl_if_blank:N}
%   \begin{syntax}
%     \cs{xtl_if_blank_p:N} \Arg{xtl~var}
%     \cs{xtl_if_blank:NTF} \Arg{xtl~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the \meta{xtl~var} consists only of blank spaces.  The test
%   is \texttt{true} if \meta{xtl~var} consists of zero or more explicit
%   space characters (explicit tokens with character code~$32$ and
%   category code~$10$), and is \texttt{false} otherwise.
% \end{function}
%
% \begin{function}[EXP,pTF]{\xtl_if_empty:N}
%   \begin{syntax}
%     \cs{xtl_if_empty_p:N} \meta{xtl~var}
%     \cs{xtl_if_empty:NTF} \meta{xtl~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the \meta{xtl~var} is entirely empty (\emph{i.e.}~contains
%   no tokens at all).
% \end{function}
%
% \begin{function}[EXP,pTF]{\xtl_if_eq:NN}
%   \begin{syntax}
%     \cs{xtl_if_eq_p:NN} \Arg{xtl~var_1} \Arg{xtl~var_2}
%     \cs{xtl_if_eq:NNTF} \Arg{xtl~var_1} \Arg{xtl~var_2} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if \meta{xtl~var_1} and \meta{xtl~var_2} have the same
%   content.  The test is \texttt{true} if the two contain the same list
%   of tokens (identical in both character code and category code).
% \end{function}
%
% \begin{function}[EXP,pTF]{\xtl_if_single_token:N}
%   \begin{syntax}
%     \cs{xtl_if_single_token_p:N} \meta{xtl~var}
%     \cs{xtl_if_single_token:NTF} \meta{xtl~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the content of the \meta{xtl~var} consists of a single
%   token.  Such a token list has token count $1$ according to
%   \cs{xtl_count_tokens:N}.
% \end{function}
%
% \begin{function}[EXP,pTF]{\xtl_if_tl:N}
%   \begin{syntax}
%     \cs{xtl_if_tl_p:N} \meta{xtl~var}
%     \cs{xtl_if_tl:NTF} \meta{xtl~var} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the \meta{xtl~var} is balanced.
% \end{function}
%
% \subsection{The first token from an extended token list}
%
% \begin{function}[EXP]{\xtl_head:N}
%   \begin{syntax}
%     \cs{xtl_head:N} \meta{xtl~var}
%   \end{syntax}
%   Leaves in the input stream the first token in the \meta{xtl~var},
%   discarding the rest of the \meta{xtl~var}.
% \end{function}
%
% \begin{function}{\xtl_get_left:NN}
%   \begin{syntax}
%     \cs{xtl_get_left:NN} \meta{xtl~var_1} \meta{xtl~var_2}
%   \end{syntax}
%   Stores the first token from \meta{xtl~var_1} in \meta{xtl~var_2} as
%   an single-token extended token list, without removing it from
%   \meta{xtl~var_1}.
% \end{function}
%
% \begin{function}{\xtl_pop_left:N, \xtl_gpop_left:N}
%   \begin{syntax}
%     \cs{xtl_pop_left:N} \meta{xtl~var}
%   \end{syntax}
%   Remove the first token from \meta{xtl~var_1}.
% \end{function}
%
% \begin{function}{\xtl_pop_left:NN, \xtl_gpop_left:NN}
%   \begin{syntax}
%     \cs{xtl_pop_left:NN} \meta{xtl~var_1} \meta{xtl~var_2}
%   \end{syntax}
%   Stores the first token from \meta{xtl~var_1} in \meta{xtl~var_2} as
%   an single-token extended token list, and remove it from
%   \meta{xtl~var_1}.
% \end{function}
%
% \begin{function}[EXP,pTF]{\xtl_if_head_eq_catcode:NN}
%   \begin{syntax}
%     \cs{xtl_if_head_eq_catcode_p:NN} \Arg{xtl~var} \meta{test token}
%     \cs{xtl_if_head_eq_catcode:NNTF} \Arg{xtl~var} \meta{test token}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the first token in \meta{xtl~var} has the same category
%   code as the \meta{test token}.  In the case where \meta{xtl~var} is
%   empty, the test will always be \texttt{false}.
% \end{function}
%
% \begin{function}[EXP,pTF]{\xtl_if_head_eq_charcode:NN}
%   \begin{syntax}
%     \cs{xtl_if_head_eq_charcode_p:NN} \Arg{xtl~var} \meta{test token}
%     \cs{xtl_if_head_eq_charcode:NNTF} \Arg{xtl~var} \meta{test token}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the first token in \meta{xtl~var} has the same character
%   code as the \meta{test token}.  In the case where \meta{xtl~var} is
%   empty, the test will always be \texttt{false}.
% \end{function}
%
% \begin{function}[EXP,pTF]{\xtl_if_head_eq_meaning:NN}
%   \begin{syntax}
%     \cs{xtl_if_head_eq_meaning_p:NN} \Arg{xtl~var} \meta{test token}
%     \cs{xtl_if_head_eq_meaning:NNTF} \Arg{xtl~var} \meta{test token}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests if the first token in \meta{xtl~var} has the same meaning as
%   the \meta{test token}.  In the case where \meta{xtl~var} is empty,
%   the test will always be \texttt{false}.
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {
%     \xtl_if_head_is_group_begin:N,
%     \xtl_if_head_is_group_end:N,
%     \xtl_if_head_is_N_type:N,
%     \xtl_if_head_is_space:N,
%   }
%   \begin{syntax}
%     \cs{xtl_if_head_is_group_begin_p:N} \Arg{xtl~var}
%     \cs{xtl_if_head_is_group_begin:NTF} \Arg{xtl~var}
%     ~~\Arg{true code} \Arg{false code}
%   \end{syntax}
%   Tests whether the first token in \meta{xtl~var} is an explicit
%   begin-group character, an explicit end-group character, an |N|-type
%   token, or a space.  In the case where \meta{xtl~var} is empty, the
%   test will always be \texttt{false}.
% \end{function}
%
% \subsection{The first few tokens from an extended token list}
%
% \begin{function}[EXP]{\xtl_left_tl:N}
%   \begin{syntax}
%     \cs{xtl_left_tl:N} \meta{xtl~var}
%   \end{syntax}
%   Leaves in the input stream all tokens in \meta{xtl~var} until the
%   first extra begin-group or extra end-group character.  This is the
%   longest balanced token list starting from the left of
%   \meta{xtl~var}.
% \end{function}
%
% \begin{function}{\xtl_pop_left_tl:N}
%   \begin{syntax}
%     \cs{xtl_pop_left_tl:N} \meta{xtl~var}
%   \end{syntax}
%   Remove from the \meta{xtl~var} all tokens before the first extra
%   begin-group or extra end-group character.  The tokens that are
%   removed form the longest balanced token list starting from the left
%   of \meta{xtl~var}.
% \end{function}
%
% \begin{function}[EXP]{\xtl_left_text:NF}
%   \begin{syntax}
%     \cs{xtl_left_text:NF} \meta{xtl~var} \Arg{false code}
%   \end{syntax}
%   Starting from the first token in \meta{xtl~var}, this function finds
%   a pattern of the form \meta{tokens_1} \Arg{tokens_2}, where the
%   \meta{tokens_1} contain no begin-group nor end-group characters,
%   then leaves \meta{tokens_1} \Arg{tokens_2} in the input stream,
%   within \cs{exp_not:n}.  If no such pattern exists (this happens if
%   the result of \cs{xtl_left_tl:N} contains no brace group), the
%   \meta{false code} is run instead.
% \end{function}
%
% \begin{function}{\xtl_pop_left_text:N, \xtl_gpop_left_text:N}
%   \begin{syntax}
%     \cs{xtl_pop_left_text:N} \meta{xtl~var}
%   \end{syntax}
%   Starting from the first token in \meta{xtl~var}, this function finds
%   a pattern of the form \meta{tokens_1} \Arg{tokens_2}, where the
%   \meta{tokens_1} contain no begin-group nor end-group characters,
%   then removes \meta{tokens_1} \Arg{tokens_2} from \meta{xtl~var}.  If
%   no such pattern exists (this happens if the result of
%   \cs{xtl_left_tl:N} contains no brace group), the \meta{xtl~var} is
%   not modified instead.
% \end{function}
%
% \subsection{Working with the contents of extended token lists}
%
% \begin{function}[EXP]{\xtl_count_tokens:N}
%   \begin{syntax}
%     \cs{xtl_count_tokens:N} \meta{xtl~var}
%   \end{syntax}
%   Counts the number of tokens in the \meta{xtl~var} and leaves this
%   information in the input stream.
% \end{function}
%
% \begin{function}[EXP]{\xtl_extra_begin:N, \xtl_extra_end:N}
%   \begin{syntax}
%     \cs{xtl_extra_begin:N} \meta{xtl~var}
%   \end{syntax}
%   Counts the number of explicit extra begin-group (or end-group)
%   characters in the \meta{xtl~var} and leaves this information in the
%   input stream.
% \end{function}
%
% \begin{function}{\xtl_show:N}
%   \begin{syntax}
%     \cs{xtl_show:N} \meta{xtl~var}
%   \end{syntax}
%   Displays the content of the \meta{xtl~var} on the terminal.
% \end{function}
%
% \begin{function}[EXP]{\xtl_to_str:N}
%   \begin{syntax}
%     \cs{xtl_to_str:N} \meta{xtl~var}
%   \end{syntax}
%   Converts the content of the \meta{xtl~var} into a series of
%   characters with category code $12$ (other) with the exception of
%   spaces, which retain category code $10$ (space).  This string is
%   then left in the input stream.
% \end{function}
%
% \subsection{Constant extended token lists}
%
% \begin{variable}{\c_empty_xtl}
%   Constant that is always empty.
% \end{variable}
%
% \begin{variable}{\c_group_begin_xtl}
%   An explicit begin-group character contained in an extended token
%   list.
% \end{variable}
%
% \begin{variable}{\c_group_end_xtl}
%   An explicit end-group character contained in an extended token list.
% \end{variable}
%
% \subsection{Future perhaps}
%
% \begin{itemize}
% \item Test if a token appears in an extended token list.
% \item Test if an extended token list appears in another.
% \item Remove an extended token list from another, once or every time
%   it appears.
% \item Replace an extended token list by another in a third: once, or
%   every time it appears.
% \item Case statement.
% \item Mapping?
% \item Inserting an extended token list into the input stream, with all
%   its glorious unbalanced braces.
% \item Convert in various ways to a token list.
% \item Reverse the order of tokens.
% \item Extract a token given its position.
% \item Extract a range of tokens given their position.
% \item Trim spaces.
% \item Crazy idea below.
% \end{itemize}
%
% We could add (with lots of work) the expandable function
% \begin{syntax}
% \cs{xtl_concat:nF}
%   \{
%     \Arg{tl_1} \Arg{start_1} \Arg{stop_1}
%     \Arg{tl_2} \Arg{start_2} \Arg{stop_2}
%     \ldots{}
%     \Arg{tl_n} \Arg{start_n} \Arg{stop_n}
%   \}
%   \Arg{false code}
% \end{verbatim}
% For each triplet, this function builds the sub-token list of <tl_i>
% corresponding to the tokens ranging from position <start_i> to
% position <stop_i> of <tl_i>.  The results obtained for each triplet
% are then concatenated.  If nothing bad happens (see below), the
% concatenation is left in the input stream, and the <false code> is
% removed.  Two cases can lead to running the <false code> (and dropping
% the first argument altogether).  The first case is when the number of
% brace groups in \xtl_concat:nF is not a multiple of 3.  The second
% case is when the concatenation gives rise to an unbalanced token list:
% then the result is not a valid token list.  Note that each part is
% allowed to be unbalanced: only the full result must be balanced.
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{xtl} implementation}
%
% Some support packages are loaded first, then we declare the package's
% name, date, version, and purpose.
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
\RequirePackage{expl3}[2012/12/21]
\ProvidesExplPackage
  {xtl} {2013/07/14} {0.0a} {Manipulate unbalanced lists of tokens}
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=xtl>
%    \end{macrocode}
%
% \subsection{Helpers}
%
% \begin{macro}[EXP, int]{\@@_brace:nn, \@@_brace_swap:nn}
%   Those functions are used to add some tokens, |#1|, to an item |#2|
%   in an extended token list: \cs{@@_brace:nn} adds tokens on the left,
%   while \cs{@@_brace_swap:nn} adds them on the right.
%    \begin{macrocode}
\cs_new:Npn \@@_brace:nn #1#2 { { #1 #2 } }
\cs_new:Npn \@@_brace_swap:nn #1#2 { { #2 #1 } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,aux]{\@@_strip_nil_mark:w,}
% \begin{macro}[EXP,aux]{\@@_strip_nil_mark_aux:w}
%   Removes the following \cs{q_nil} \cs{q_mark} without losing any
%   braces, and places the result into \cs{exp_not:n}.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_strip_nil_mark:w
  { \@@_strip_nil_mark_aux:w \exp_stop_f: }
\cs_new:Npn \@@_strip_nil_mark_aux:w #1 \q_nil \q_mark
  { \exp_not:f {#1} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Structure of extended token lists}
%
% Token lists must have balanced braces (or rather, begin-group and
% end-group characters).  Extended token lists lift this requirement,
% and can represent arbitrary lists of tokens.  A list of tokens can
% fail to be balanced in two ways: one may encounter too many end-group
% characters near the beginning of the list, or too many begin-group
% characters near the end of the list.  In fact, a list of tokens always
% has the form
% \begin{quote}\ttfamily
%   \meta{b_1} \} \cdots \meta{b_n} \}
%   \meta{c}
%   \{ \meta{e_1} \cdots \{ \meta{e_p}
% \end{quote}
% where the \meta{b_i}, \meta{c}, and \meta{e_i} are all balanced token
% lists.  This can be seen by listing the tokens, and keeping track of a
% counter, which starts at~$0$, and is incremented at each begin-group
% character, and decremented at each end-group character: then the
% \meta{b_i} are delimited by positions where the counter reaches a new
% minimum, whereas the \meta{e_i} are delimited by positions where the
% counter last takes a given negative value.  Such a token list is
% stored as
% \begin{quote}\ttfamily
%   \cs{s_@@}
%   \{ \Arg{b_1} \cdots \Arg{b_n} \}
%   \Arg{c}
%   \{ \Arg{e_p} \cdots \Arg{e_1} \}
%   \cs{s__stop}
% \end{quote}
% Note that the \meta{e_i} are in a reversed order, as this makes the
% ends of extended token lists more accessible.  Balanced token lists
% have $n = p = 0$: the first and third parts are empty, while the
% second contains the tokens.
%
% \begin{variable}{\s_@@}
%   This marker appears at the start of extended token lists.
%    \begin{macrocode}
\__scan_new:N \s_@@
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\xtl_set:Nn, \xtl_gset:Nn, \xtl_const:Nn}
%   Storing a balanced token list into an extended token list variable
%   simply means adding \cs{s_@@}, \cs{s__stop}, and two empty brace
%   groups.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xtl_set:Nn   { \@@_set:NNn \tl_set:Nn   }
\cs_new_protected_nopar:Npn \xtl_gset:Nn  { \@@_set:NNn \tl_gset:Nn  }
\cs_new_protected_nopar:Npn \xtl_const:Nn { \@@_set:NNn \tl_const:Nn }
\cs_new_protected:Npn \@@_set:NNn   #1#2#3
  { #1 #2 { \s_@@ { } {#3} { } \s__stop } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xtl_set:Nx, \xtl_gset:Nx, \xtl_const:Nx}
%   Storing a balanced token list into an extended token list variable
%   simply means adding \cs{s_@@}, \cs{s__stop}, and two empty brace
%   groups.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \xtl_set:Nx   { \@@_set:NNn \tl_set:Nx   }
\cs_new_protected_nopar:Npn \xtl_gset:Nx  { \@@_set:NNn \tl_gset:Nx  }
\cs_new_protected_nopar:Npn \xtl_const:Nx { \@@_set:NNn \tl_const:Nx }
\cs_new_protected:Npn \@@_set:NNn   #1#2#3
  { #1 #2 { \s_@@ { } {#3} { } \s__stop } }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\c_empty_xtl}
%   An empty extended token list, obtained thanks to the
%   \cs{xtl_const:Nn} function just defined.
%    \begin{macrocode}
\xtl_const:Nn \c_empty_xtl { }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_group_begin_xtl, \c_group_end_xtl}
%   An extended token list with exactly one begin-group/end-group
%   character.
%    \begin{macrocode}
\tl_const:Nn \c_group_end_xtl   { \s_@@ { { } } { } {     } \s__stop }
\tl_const:Nn \c_group_begin_xtl { \s_@@ {     } { } { { } } \s__stop }
%    \end{macrocode}
% \end{variable}
%
% \subsection{Creating extended token list variables}
%
% \begin{macro}{\xtl_new:N}
%   A new extended token list is created empty.
%    \begin{macrocode}
\cs_new_protected:Npn \xtl_new:N #1
  { \cs_new_eq:NN #1 \c_empty_xtl }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xtl_set_eq:NN, \xtl_gset_eq:NN}
%   All the data about an extended token list is stored as a single
%   token list, so copying is easy.
%    \begin{macrocode}
\cs_new_eq:NN \xtl_set_eq:NN  \tl_set_eq:NN
\cs_new_eq:NN \xtl_gset_eq:NN \tl_gset_eq:NN
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xtl_clear:N, \xtl_gclear:N}
%   Clearing an extended token list by setting it to the empty one.
%    \begin{macrocode}
\cs_new_protected:Npn \xtl_clear:N  #1
  { \xtl_set_eq:NN  #1 \c_empty_xtl }
\cs_new_protected:Npn \xtl_gclear:N #1
  { \xtl_gset_eq:NN #1 \c_empty_xtl }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\xtl_clear_new:N, \xtl_gclear_new:N}
%   If the variable exists, clear it.  Otherwise declare it.
%    \begin{macrocode}
\cs_new_protected:Npn \xtl_clear_new:N #1
  { \xtl_if_exist:NTF #1 { \xtl_clear:N #1 } { \xtl_new:N #1 } }
\cs_new_protected:Npn \xtl_gclear_new:N #1
  { \xtl_if_exist:NTF #1 { \xtl_gclear:N #1 } { \xtl_new:N #1 } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\xtl_if_exist:N}
%   Again a copy of token list functions.
%    \begin{macrocode}
\prg_new_eq_conditional:NNn \xtl_if_exist:N \tl_if_exist:N
  { p , T , F , TF }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Adding data to extended token list variables}
%
% \begin{macro}{\xtl_put_left:Nn, \xtl_gput_left:Nn}
% \begin{macro}[aux]{\@@_put_left:wNNn}
%    \begin{macrocode}
\cs_new_protected:Npn \xtl_put_left:Nn #1
  { \exp_after:wN \@@_put_left:wNNn #1 \tl_set:Nx #1 }
\cs_new_protected:Npn \xtl_put_left:Nn #1
  { \exp_after:wN \@@_put_left:wNNn #1 \tl_gset:Nx #1 }
\cs_new_protected:Npn \@@_put_left:wNNn \s_@@ #1#2#3 \s__stop #4#5#6
  {
    \tl_if_empty:nTF {#1}
      { #4 #5 { \exp_not:n { \s_@@ { } { #6 #2 } {#3} \s__stop } } }
      {
        #4 #5
          {
            \s_@@
            { \exp_not:o { \@@_brace:nn {#6} #1 } }
            { \exp_not:n {#2} }
            { \exp_not:n {#3} }
            \s__stop
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xtl_put_right:Nn, \xtl_gput_right:Nn}
% \begin{macro}[aux]{\@@_put_right:wNNn}
%    \begin{macrocode}
\cs_new_protected:Npn \xtl_put_right:Nn #1
  { \exp_after:wN \@@_put_right:wNNn #1 \tl_set:Nx #1 }
\cs_new_protected:Npn \xtl_put_right:Nn #1
  { \exp_after:wN \@@_put_right:wNNn #1 \tl_gset:Nx #1 }
\cs_new_protected:Npn \@@_put_right:wNNn \s_@@ #1#2#3 \s__stop #4#5#6
  {
    \tl_if_empty:nTF {#3}
      { #4 #5 { \exp_not:n { \s_@@ {#1} { #2 #6 } { } \s__stop } } }
      {
        #4 #5
          {
            \s_@@
            { \exp_not:n {#1} }
            { \exp_not:n {#2} }
            { \exp_not:o { \@@_brace_swap:nn {#6} #3 } }
            \s__stop
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xtl_concat:NNN, \xtl_gconcat:NNN}
% \begin{macro}[EXP, aux]
%   {
%     \@@_concat:ww,
%     \@@_concat_aux:nnnnnn,
%     \@@_concat_auxi:nnnnnn,
%     \@@_concat_auxii:nnnnnn,
%     \@@_concat_auxiii:w,
%     \@@_concat_auxiv:nnnn,
%     \@@_concat_auxv:wnwnn,
%     \@@_concat_auxvi:nnwnwnn
%   }
%   Concatenating two lists of tokens of the form
%   \begin{quote}\ttfamily
%     \cs{s_@@}
%     \{ \Arg{b_1} \cdots \Arg{b_n} \}
%     \Arg{c}
%     \{ \Arg{e_p} \cdots \Arg{e_1} \}
%     \cs{s__stop}
%   \end{quote}
%   is not an easy task.  The \meta{e} parts of the first join with the
%   \meta{b} parts of the second to make balanced pairs, and the
%   follow-up depends on whether there were more \meta{e} parts or more
%   \meta{b} parts.
%    \begin{macrocode}
\cs_new_protected:Npn \xtl_concat:NNN #1#2#3
  { \tl_set:Nx  #1 { \exp_last_two_unbraced:Noo \@@_concat:ww #2 #3 } }
\cs_new_protected:Npn \xtl_gconcat:NNN #1#2#3
  { \tl_gset:Nx #1 { \exp_last_two_unbraced:Noo \@@_concat:ww #2 #3 } }
\cs_new:Npn \@@_concat:ww \s_@@ #1#2#3 \s__stop \s_@@ #4#5#6 \s__stop
  {
    \tl_if_blank:nTF {#3}
      {
        \tl_if_blank:nTF {#4}
          { \@@_concat_aux:nnnnnn }
          { \@@_concat_auxi:nnnnnn }
      }
      {
        \tl_if_blank:nTF {#5}
          { \@@_concat_auxii:nnnnnn }
          { \@@_concat_auxiv:nnnn }
      }
      {#1} {#2} {#3} {#4} {#5} {#6}
    \s__stop
  }
\cs_new:Npn \@@_concat_aux:nnnnnn #1#2#3#4#5#6
  { \exp_not:n { \s_@@ {#1} { #2 #5 } {#6} } }
\cs_new:Npn \@@_concat_auxi:nnnnnn #1#2#3#4#5#6
  {
    \s_@@
    {
      \exp_not:n {#1}
      \exp_last_unbraced:NNo \@@_concat_auxiii:w
        \prg_do_nothing: { \@@_brace:nn {#2} #4 } \q_stop
    }
    { \exp_not:n {#5} }
    { \exp_not:n {#6} }
  }
\cs_new:Npn \@@_concat_auxii:nnnnnn #1#2#3#4#5#6
  {
    \s_@@
    { \exp_not:n {#1} }
    { \exp_not:n {#2} }
    {
      \exp_not:n {#6}
      \exp_last_unbraced:NNo \@@_concat_auxiii:w
        \prg_do_nothing: { \@@_brace_swap:nn {#5} #3 } \q_stop
    }
  }
\cs_new:Npn \@@_concat_auxiii:w #1 ~ #2 \q_stop { \exp_not:o {#1} }
\cs_new:Npn \@@_concat_auxiv:nnnn #1#2#3#4
  {
    \tl_if_single:nTF {#3}
      { \@@_concat_auxv:wnwnn }
      { \@@_concat_auxvi:nnwnwnn }
    #3 ~ \q_mark #4 ~ \q_mark {#1} {#2}
  }
\cs_new:Npn \@@_concat_auxv:wnwnn
    #1#2 \q_mark #3#4 \q_mark #5#6
  {
    \@@_concat:ww
      \s_@@ {#5} { #6 { #1 #3 } } { } \s__stop
      \s_@@ {#4}
  }
\cs_new:Npn \@@_concat_auxvi:nnwnwnn
    #1#2#3 \q_mark #4#5 \q_mark #6#7
  {
    \@@_concat:ww
      \s_@@ {#6} {#7} { { #2 { #1 #4 } } #3 } \s__stop
      \s_@@ {#5}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Showing extended token lists}
%
% \begin{macro}[EXP]{\xtl_to_str:N}
% \begin{macro}[EXP, aux]
%   {
%     \@@_to_str:w,
%     \@@_to_str_loopi:nnw,
%     \@@_to_str_testi:nnw,
%     \@@_to_str_endi:nnn,
%     \@@_to_str_loopii:nnw,
%     \@@_to_str_endii:nnw
%   }
%    \begin{macrocode}
\cs_new:Npn \xtl_to_str:N #1 { \exp_after:wN \@@_to_str:w #1 }
\cs_new:Npn \@@_to_str:w \s_@@ #1#2#3 \s__stop
  { \@@_to_str_loopi:nnw { } #1 \q_nil \q_mark {#2} {#3} }
\cs_new:Npx \@@_to_str_loopi:nnw #1#2
  {
    \exp_not:N \quark_if_nil:nTF {#2}
      { \exp_not:N \@@_to_str_testi:nnw {#1} {#2} }
      { \exp_not:N \@@_to_str_loopi:nnw { #1 #2 \iow_char:N \} } }
  }
\cs_new:Npx \@@_to_str_testi:nnw #1#2#3 \q_mark
  {
    \exp_not:N \tl_if_empty:nTF {#3}
      { \exp_not:N \@@_to_str_endi:nnn {#1} }
      {
        \exp_not:N \@@_to_str_loopi:nnw
          { #1 #2 \iow_char:N \} } #3 \q_mark
      }
  }
\cs_new:Npn \@@_to_str_endi:nnn #1#2#3
  { \@@_to_str_loopii:nnw #3 { #1 #2 } \q_nil \q_stop }
\cs_new:Npx \@@_to_str_loopii:nnw #1#2
  {
    \exp_not:N \quark_if_nil:nTF {#2}
      { \exp_not:N \@@_to_str_testii:nnw {#1} {#2} }
      { \exp_not:N \@@_to_str_loopii:nnw { #2 \iow_char:N \{ #1 } }
  }
\cs_new:Npx \@@_to_str_testii:nnw #1#2#3 \q_stop
  {
    \exp_not:N \tl_if_empty:nTF {#3}
      { \exp_not:N \tl_to_str:n {#1} }
      {
        \exp_not:N \@@_to_str_loopii:nnw
          { #2 \iow_char:N \{ #1 } #3 \q_stop
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xtl_show:N}
%   Display the variable name, then its string representation.
%    \begin{macrocode}
\cs_new_protected:Npn \xtl_show:N #1
  { \exp_args:Nx \tl_show:n { \token_to_str:N #1 = \xtl_to_str:N #1 } }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Extended token list conditionals}
%
% \begin{macro}[EXP, pTF]{\xtl_if_eq:NN}
%   Two extended token lists are equal if their contents agree.
%    \begin{macrocode}
\prg_new_conditional:Npnn \xtl_if_eq:NN #1#2 { p , T , F , TF }
  { \tl_if_eq:NNTF #1 #2 { \prg_return_true: } { \prg_return_false: } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\xtl_if_empty:N}
%   An extended token list is empty if it is equal to the empty one.
%    \begin{macrocode}
\prg_new_conditional:Npnn \xtl_if_empty:N #1 { p , T , F , TF }
  {
    \tl_if_eq:NNTF #1 \c_empty_xtl
      { \prg_return_true: } { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\xtl_if_tl:N}
% \begin{macro}[EXP,aux]{\@@_if_tl_return:w}
%    \begin{macrocode}
\prg_new_conditional:Npnn \xtl_if_tl:N #1 { p , T , F , TF }
  { \exp_after:wN \@@_if_tl_return:w #1 }
\cs_new:Npn \@@_if_tl_return:w \s_@@ #1#2#3 \s__stop
  {
    \tl_if_empty:nTF { #1 #3 }
      { \prg_return_true: } { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\xtl_if_single_token:N}
% \begin{macro}[EXP,aux]{\@@_if_single_token_return:w}
%    \begin{macrocode}
\prg_new_conditional:Npnn \xtl_if_single_token:N #1 { p , T , F , TF }
  { \exp_after:wN \@@_if_single_token_return:w #1 }
\cs_new:Npn \@@_if_single_token_return:w \s_@@ #1#2#3 \s__stop
  {
    \bool_if:nTF
      {
        \tl_if_empty_p:n {#2}
        && \tl_if_single_p:n { #1 #3 }
        && \tl_if_empty_p:o { \use:n #1 #3 }
        ||
        \tl_if_single_token_p:n {#2}
        && \tl_if_empty_p:n { #1 #3 }
      }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\xtl_if_blank:N}
% \begin{macro}[EXP,aux]{\@@_if_blank_return:w}
%    \begin{macrocode}
\prg_new_conditional:Npnn \xtl_if_blank:N #1 { p , T , F , TF }
  { \exp_after:wN \@@_if_blank_return:w #1 }
\cs_new:Npn \@@_if_blank_return:w \s_@@ #1#2#3 \s__stop
  {
    \tl_if_blank:nTF { #1 #2 #3 }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP,pTF]
%   {
%     \xtl_if_head_is_group_begin:N,
%     \xtl_if_head_is_group_end:N,
%     \xtl_if_head_is_space:N,
%     \xtl_if_head_is_N_type:N,
%   }
%    \begin{macrocode}
\prg_new_conditional:Npnn \xtl_if_head_is_group_begin:N #1
  { p , T , F , TF }
  {
    \exp_after:wN \@@_head:wnnnnn #1
      { \prg_return_false: }
      { \prg_return_true: }
      { \prg_return_false: }
      { \prg_return_false: }
      { \prg_return_false: \use_none:n }
  }
\prg_new_conditional:Npnn \xtl_if_head_is_group_end:N #1
  { p , T , F , TF }
  {
    \exp_after:wN \@@_head:wnnnnn #1
      { \prg_return_false: }
      { \prg_return_false: }
      { \prg_return_true: }
      { \prg_return_false: }
      { \prg_return_false: \use_none:n }
  }
\prg_new_conditional:Npnn \xtl_if_head_is_space:N #1
  { p , T , F , TF }
  {
    \exp_after:wN \@@_head:wnnnnn #1
      { \prg_return_false: }
      { \prg_return_false: }
      { \prg_return_false: }
      { \prg_return_true: }
      { \prg_return_false: \use_none:n }
  }
\prg_new_conditional:Npnn \xtl_if_head_is_N_type:N #1
  { p , T , F , TF }
  {
    \exp_after:wN \@@_head:wnnnnn #1
      { \prg_return_false: }
      { \prg_return_false: }
      { \prg_return_false: }
      { \prg_return_false: }
      { \prg_return_true: \use_none:n }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\xtl_if_head_eq_catcode:NN}
% \begin{macro}[EXP, pTF]{\xtl_if_head_eq_charcode:NN}
% \begin{macro}[EXP, aux]{\@@_if_head_eq_code_return:NNN}
%   In the empty case, |?| can match with |#2|, but then
%   \cs{use_none:nn} gets rid of \cs{prg_return_true:} and \cs{else:},
%   to correctly leave \cs{prg_return_false:}.  We could not simplify
%   this by placing the \cs{exp_not:N} |#2| after the construction
%   involving~|#1|, because |#2|~must be taken into the \TeX{} primitive
%   test, in case |#2|~itself is a primitive \TeX{} conditional, which
%   would mess up conditional nesting.
%    \begin{macrocode}
\prg_new_conditional:Npnn \xtl_if_head_eq_catcode:NN #1#2
  { p , T , F , TF }
  { \@@_if_head_eq_code_return:NNN \if_catcode:w #1#2 }
\prg_new_conditional:Npnn \xtl_if_head_eq_charcode:NN #1#2
  { p , T , F , TF }
  { \@@_if_head_eq_code_return:NNN \if_charcode:w #1#2 }
\cs_new:Npn \@@_if_head_eq_code_return:NNN #1#2#3
  {
    #1
        \exp_not:N #3
        \exp_after:wN \@@_head:wnnnnn #2
          { ? \use_none:nn }
          { \c_group_begin_token }
          { \c_group_end_token }
          { \c_space_token }
          { \exp_not:N }
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP, pTF]{\xtl_if_head_eq_meaning:NN}
% \begin{macro}[EXP, aux]{\@@_if_head_eq_meaning_return:NN}
%    \begin{macrocode}
\prg_new_conditional:Npnn \xtl_if_head_eq_meaning:NN #1#2
  { p , T , F , TF }
  { \@@_if_head_eq_meaning_return:NN #1#2 }
\cs_new:Npn \@@_if_head_eq_meaning_return:NN #1#2
  {
    \exp_after:wN \@@_head:wnnnnn #1
      { \if_false: }
      { \if_meaning:w #2 \c_group_begin_token }
      { \if_meaning:w #2 \c_group_end_token }
      { \if_meaning:w #2 \c_space_token }
      { \if_meaning:w #2 }
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{First token of an extended token list}
%
% \begin{macro}[EXP]{\xtl_head:N}
% \begin{macro}{\xtl_get_left:NN}
% \begin{macro}[EXP, aux]{\@@_head:wnnnnn, \@@_head_aux:nwnnnn}
%   The function \cs{xtl_head:N} leaves the first token in the input
%   stream, even if it is a begin-group or end-group character.  Both
%   \cs{xtl_head:N} and \cs{xtl_get_left:NN} pass the extended token
%   list to \cs{@@_head:wnnnn}, followed by the action to perform in
%   various cases.  This function performs |#4|~if the \texttt{xtl} is
%   empty, |#5|~if it starts with a begin-group character, |#6|~if it
%   starts with an end-group character, |#7|~if it starts with a space,
%   and in other cases (when the first token is |N|-type), it performs
%   |#7|~followed by the first token.
%    \begin{macrocode}
\cs_new:Npn \xtl_head:N #1
  {
    \exp_after:wN \@@_head:wnnnnn #1
      { }
      { \exp_after:wN { \if_false: } \fi: }
      { \if_false: { \fi: } }
      { ~ }
      { }
  }
\cs_new_protected:Npn \xtl_get_left:NN #1#2
  {
    \exp_after:wN \@@_head:wnnnnn #1
      { \xtl_set:Nn #2 { \q_no_value } }
      { \xtl_set_eq:NN #2 \c_group_begin_xtl }
      { \xtl_set_eq:NN #2 \c_group_end_xtl }
      { \xtl_set:Nn #2 { ~ } }
      { \xtl_set:Nx #2 }
  }
\cs_new:Npn \@@_head:wnnnnn \s_@@ #1#2#3 \s__stop #4#5#6#7#8
  {
    \tl_if_empty:nTF {#1}
      {
        \tl_if_empty:nTF {#2}
          { \tl_if_empty:nTF {#3} {#4} {#5} }
          { \@@_head_aux:nwnnnn {#2} \q_stop {#5} {#6} {#7}a {#8} }
      }
      { \@@_head_aux:nwnnnn #1 \q_stop {#5} {#6} {#7} {#8} }
  }
\cs_new:Npn \@@_head_aux:nwnnnn #1#2 \q_stop #3#4#5#6
  {
    \tl_if_head_is_group:nTF {#1} {#3}
      {
        \tl_if_empty:nTF {#1} {#4}
          {
            \tl_if_head_is_space:nTF {#1} {#5}
              { \exp_last_unbraced:Nf #6 { \tl_head:n {#1} } }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xtl_pop_left:N, \xtl_gpop_left:N}
% \begin{macro}[aux, rEXP]
%   {
%     \@@_pop_left:w,
%     \@@_pop_left_auxi:n,
%     \@@_pop_left_auxii:nnnw,
%     \@@_pop_left_auxiii:nnnw,
%     \@@_pop_left_auxiv:nn,
%     \@@_pop_left_auxv:nnn,
%     \@@_pop_left_auxvi:n
%   }
%    \begin{macrocode}
\cs_new_protected:Npn \xtl_pop_left:N #1
  { \tl_set:Nx #1 { \exp_after:wN \@@_pop_left:w #1 } }
\cs_new_protected:Npn \xtl_gpop_left:N #1
  { \tl_gset:Nx #1 { \exp_after:wN \@@_pop_left:w #1 } }
\cs_new:Npn \@@_pop_left:w \s_@@ #1#2#3 \s__stop
  {
    \tl_if_empty:nTF {#1}
      {
        \tl_if_empty:nTF {#2}
          {
            \tl_if_empty:nTF {#3}
              { \s_@@ { } { } { } \s__stop }
              { \@@_pop_left_auxi:n {#3} }
          }
          { \@@_pop_left_auxiv:nn {#2} {#3} }
      }
      { \@@_pop_left_auxv:nnn {#1} {#2} {#3} }
  }
\cs_new:Npn \@@_pop_left_auxi:n #1
  {
    \s_@@
    { }
    \@@_pop_left_auxii:nnnw { } { } #1 \q_nil \q_stop
    \s__stop
  }
\cs_new:Npn \@@_pop_left_auxii:nnnw #1#2#3
  {
    \quark_if_nil:nTF {#3}
      { \@@_pop_left_auxiii:nnnw {#1} {#2} {#3} }
      { \@@_pop_left_auxii:nnnw { #1 #2 } { {#3} } }
  }
\cs_new:Npn \@@_pop_left_auxiii:nnnw #1#2#3#4 \q_stop
  {
    \tl_if_empty:nTF {#4}
      { \exp_not:n { {#2} {#1} } }
      { \@@_pop_left_auxii:nnnw { #1 #2 } { {#3} } }
  }
\cs_new:Npn \@@_pop_left_auxiv:nn #1#2
  {
    \s_@@
    { \tl_if_head_is_group:nT {#1} { { \tl_head:n {#1} } } }
    { \tl_if_head_is_space:nTF {#1} { \exp_not:f } { \tl_tail:n } {#1} }
    { \exp_not:n {#2} }
    \s__stop
  }
\cs_new:Npn \@@_pop_left_auxv:nnn #1#2#3
  {
    \s_@@
    { \if_false: { \fi: \@@_pop_left_auxvi:n #1 } }
    { \exp_not:n {#2} }
    { \exp_not:n {#3} }
    \s__stop
  }
\cs_new:Npn \@@_pop_left_auxvi:n #1
  {
    \tl_if_empty:nF {#1}
      {
        \tl_if_head_is_group:nT {#1} { { \tl_head:n {#1} } }
        {
          \tl_if_head_is_space:nTF {#1}
            { \exp_not:f } { \tl_tail:n } {#1}
        }
      }
    \exp_after:wN \exp_not:n \exp_after:wN { \if_false: } \fi:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xtl_pop_left:NN, \xtl_gpop_left:NN}
%   Getting the first token and removing it from the extended token list
%   is done in two steps.
%    \begin{macrocode}
\cs_new_protected:Npn \xtl_pop_left:NN #1#2
  {
    \xtl_get_left:NN #1 #2
    \xtl_pop_left:N #1
  }
\cs_new_protected:Npn \xtl_gpop_left:NN #1#2
  {
    \xtl_get_left:NN #1 #2
    \xtl_gpop_left:N #1
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Longest token list starting an extended token list}
%
% \begin{macro}[EXP]{\xtl_left_tl:N}
% \begin{macro}[EXP,aux]{\@@_left_tl:w}
%    \begin{macrocode}
\cs_new:Npn \xtl_left_tl:N #1
  { \exp_after:wN \@@_left_tl:w #1 }
\cs_new:Npn \@@_left_tl:w \s_@@ #1#2#3 \s__stop
  { \tl_if_empty:nTF {#1} { \exp_not:n {#2} } { \tl_head:n {#1} } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xtl_pop_left_tl:N, \xtl_gpop_left_tl:N}
%    \begin{macrocode}
\cs_new_protected:Npn \xtl_pop_left_tl:N #1
  { \tl_set:Nx #1 { \exp_after:wN \@@_pop_left_tl:w #1 } }
\cs_new_protected:Npn \xtl_gpop_left_tl:N #1
  { \tl_gset:Nx #1 { \exp_after:wN \@@_pop_left_tl:w #1 } }
\cs_new:Npn \@@_pop_left_tl:w \s_@@ #1#2#3 \s__stop
  {
    \s_@@
    \tl_if_empty:nTF {#1}
      { { } { } }
      {
        { \tl_tail:n {#1} }
        { \exp_not:n {#2} }
      }
    { \exp_not:n {#3} }
    \s__stop
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{First group in an extended token list}
%
% The functions of this section extract from an extended token list the
% tokens that would be absorbed after |\def\foo|, namely tokens with no
% begin-group nor end-group characters, followed by one group.  Those
% tokens are either left in the input stream or stored in a token list
% variable, and the |pop| functions also remove those tokens from the
% extended token list variable.
%
% \begin{macro}[EXP]{\xtl_left_text:NF}
% \begin{macro}[EXP,aux]
%   {
%     \@@_left_text:wF,
%     \@@_left_text_auxi:nwF,
%     \@@_left_text_auxii:wnwF,
%     \@@_left_text_auxiii:nnwF,
%   }
%    \begin{macrocode}
\cs_new:Npn \xtl_left_text:NF #1
  { \exp_after:wN \@@_left_text:wF #1 }
\cs_new:Npn \@@_left_text:wF \s_@@ #1#2#3 \s__stop
  {
    \tl_if_empty:nTF {#1}
      { \@@_left_text_auxi:nwF {#2} \q_stop }
      { \@@_left_text_auxi:nwF #1 \q_stop }
  }
\cs_new:Npn \@@_left_text_auxi:nwF #1#2 \q_stop
  { \@@_left_text_auxii:wnwF #1 \q_mark { } \q_mark \q_stop }
\cs_new:Npn \@@_left_text_auxii:wnwF #1 #
  { \@@_left_text_auxiii:nnwF {#1} }
\cs_new:Npn \@@_left_text_auxiii:nnwF #1#2 #3 \q_mark #4 \q_stop #5
  { \tl_if_empty:nTF {#4} {#5} { \exp_not:n { #1 {#2} } } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xtl_pop_left_text:N, \xtl_gpop_left_text:N}
% \begin{macro}[EXP, aux]
%   {
%     \@@_pop_left_text:w,
%     \@@_pop_left_text_auxi:n,
%     \@@_pop_left_text_auxii:wnw,
%     \@@_pop_left_text_auxiii:nnw,
%     \@@_pop_left_text_auxiv:nw,
%   }
%    \begin{macrocode}
\cs_new_protected:Npn \xtl_pop_left_text:N #1
  { \tl_set:Nx #1 { \exp_after:wN \@@_pop_left_text:w #1 } }
\cs_new_protected:Npn \xtl_gpop_left_text:N #1
  { \tl_gset:Nx #1 { \exp_after:wN \@@_pop_left_text:w #1 } }
\cs_new:Npn \@@_pop_left_text:w \s_@@ #1#2#3 \s__stop
  {
    \s_@@
    \tl_if_empty:nTF {#1}
      {
        { }
        { \@@_pop_left_text_auxi:n {#2} }
      }
      {
        { \@@_pop_left_text_auxiv:nw #1 \q_nil \q_mark }
        { \exp_not:n {#2} }
      }
    { \exp_not:n {#3} }
    \s__stop
  }
\cs_new:Npn \@@_pop_left_text_auxi:n #1
  {
    \@@_pop_left_text_auxii:wn #2
      \q_nil \q_mark { } \q_mark \q_stop
  }
\cs_new:Npn \@@_pop_left_text_auxii:wnw #1 #
  { \@@_pop_left_text_auxiii:nnw {#1} }
\cs_new:Npn \@@_pop_left_text_auxiii:nnw #1#2#3 \q_mark #4 \q_stop
  {
    \tl_if_empty:nTF {#4}
      { \@@_strip_nil_mark:w #1 }
      { \@@_strip_nil_mark:w #3 \q_mark }
  }
\cs_new:Npn \@@_pop_left_text_auxiv:nw #1
  {
    { \@@_pop_left_text_auxi:n {#1} }
    \@@_strip_nil_mark:w
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\xtl_pop_left_text:NN, \xtl_gpop_left_text:NN}
%    \begin{macrocode}
\cs_new_protected:Npn \xtl_pop_left_text:NN #1#2
  {
    \xtl_get_left_text:NN #1#2
    \xtl_pop_left_text:N #1
  }
\cs_new_protected:Npn \xtl_gpop_left_text:NN #1#2
  {
    \xtl_get_left_text:NN #1#2
    \xtl_gpop_left_text:N #1
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Counting tokens}
%
% \begin{macro}[EXP, int]{\@@_tl_count:n}
% \begin{macro}[EXP, aux]{\@@_tl_count_loop:n, \@@_tl_count_test:w}
%   A more robust version of \cs{tl_count:n}, which will however break
%   if the token list contains \cs{q_stop} at the outer brace level.
%   This cannot happen when \cs{@@_tl_count:n} is called with lists of
%   braced items.  The technique is to loop, and when seeing
%   \cs{q_mark}, make sure that this is really the end of the list.
%    \begin{macrocode}
\cs_new:Npn \@@_tl_count:n #1
  { \int_eval:n { \c_zero \@@_tl_count_loop:n #1 \q_nil \q_stop } }
\cs_new:Npn \@@_tl_count_loop:n #1
  {
    \quark_nil:nTF {#1}
      { \@@_tl_count_test:w }
      { + \c_one \@@_tl_count_loop:n }
  }
\cs_new:Npn \@@_tl_count_test:w #1 \q_stop
  { \tl_if_empty:nF {#1} { + \c_one \@@_tl_count_loop:n #1 \q_stop } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\xtl_extra_begin:N, \xtl_extra_end:N}
% \begin{macro}[EXP, aux]{\@@_extra_begin:w, \@@_extra_end:w}
%   Count the number of extra end-group or of extra begin-group
%   characters in an extended token list.  This is the number of items
%   in the first or third brace groups.  We cannot use \cs{tl_count:n},
%   as \pkg{xtl} is meant to be robust against inclusion of quarks.
%    \begin{macrocode}
\cs_new:Npn \xtl_extra_end:N #1
  { \exp_after:wN \@@_extra_end:w #1 }
\cs_new:Npn \@@_extra_end:w \s_@@ #1#2#3 \s__stop
  { \@@_tl_count:n {#1} }
\cs_new:Npn \xtl_extra_begin:N #1
  { \exp_after:wN \@@_extra_begin:w #1 }
\cs_new:Npn \@@_extra_begin:w \s_@@ #1#2#3 \s__stop
  { \@@_tl_count:n {#3} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\xtl_count_tokens:N}
% \begin{macro}[aux, rEXP]
%   {
%     \@@_count_tokens:w,
%     \@@_count_auxi:nw,
%     \@@_count_auxii:w,
%     \@@_count_auxiii:n
%   }
%    \begin{macrocode}
\cs_new:Npn \xtl_count_tokens:N #1
  { \exp_after:wN \@@_count_tokens:w #1 }
\cs_new:Npn \@@_count_tokens:w \s_@@ #1#2#3 \s__stop
  {
    \int_eval:n
      { \c_minus_one \@@_count_auxi:nw #1 {#2} #3 \q_nil \q_stop }
  }
\cs_new:Npn \@@_count_auxi:nw #1
  {
    \quark_if_nil:nTF {#1}
      { \@@_count_auxii:w }
      {
        + \c_one
        \@@_count_auxiii:n {#1}
        \@@_count_auxi:nw
      }
  }
\cs_new:Npn \@@_count_auxii:w #1 \q_stop
  {
    \tl_if_empty:nF {#1}
      {
        + \c_two
        \@@_count_auxi:nw #1 \q_stop
      }
  }
\cs_new:Npn \@@_count_auxiii:n #1
  {
    \tl_if_empty:nF {#1}
      {
        \tl_if_head_is_group:nTF {#1}
          {
            + \c_two
            \exp_args:No \@@_count_auxiii:n { \use:n #1 }
          }
          {
            + \c_one
            \tl_if_head_is_N_type:nTF {#1}
              { \exp_args:No \@@_count_auxiii:n { \use_none:n #1 } }
              { \exp_args:Nf \@@_count_auxiii:n {#1} }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \endinput
